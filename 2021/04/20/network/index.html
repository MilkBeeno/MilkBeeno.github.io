<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="MilkeBeeno&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      客户端网络通信 | MilkBeeno
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 5.4.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>MilkBeeno</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">项目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">作者</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">项目</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">作者</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>客户端网络通信</h2>
  <p class="post-date">2021-04-20</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><p>&emsp;&emsp;计算机网络学习的核心内容就是网络协议的学习，网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。作为Android开发工程师必须掌握基础的网络相关知识，主要涵盖TCP/IP协议、UDP协议、HTTP协议和Socket等。</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><table>
<thead>
<tr>
<th>TCP/IP模型</th>
<th>OSI模型</th>
<th>TCP/IP协议族</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>应用层</td>
<td>TFTP、HTTP、SNMP、FTP、DNS、Telnet</td>
<td>文件传输、电子邮件、文件服务、虚拟终端</td>
</tr>
<tr>
<td>应用层</td>
<td>表示层</td>
<td></td>
<td>数据格式转换、代码转换、数据加密</td>
</tr>
<tr>
<td></td>
<td>会话层</td>
<td></td>
<td>接触或建立与别的接点的联系</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>TCP、UDP</td>
<td>提供端对端的接口</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>IP、ICMP、RIP、OSPF、BGP、IGMP</td>
<td>为数据包选择路由</td>
</tr>
<tr>
<td>链路层</td>
<td>链路层</td>
<td>SLIP、CSLIP、PPP、ARP、PARP、MTU</td>
<td>传输有地址的帧以及错误检测功能</td>
</tr>
<tr>
<td></td>
<td>物理层</td>
<td></td>
<td>以二进制数据形式在物理媒体上传输数据</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;网络数据的传输是以包的形式进行，其工作流程就是拼包和拆包。在数据传输过程中，包是全能性术语，除此还有帧用于表示数据链路层中包的单位、片是IP中数据的单位、段则表示TCP数据流中的信息、消息表示应用协议中数据的单位。首先在应用层获取应用协议传过来的数据、经过传输层附加TCP包首部、经过网络层附加IP包首部、再经过数据链路层附加以太网包首部、最后经过物理层传输到达目标点进行逆向解包，最终展示给用户。</p>
<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p>&emsp;&emsp;TCP/IP协议簇是Internet的基础，也是当今最流行的组网形式。TCP/IP是一组协议的代名词，包括许多别的协议，组成了TCP/IP协议簇。其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等。</p>
<ul>
<li><p>协议介绍<br>&emsp;&emsp;TCP:面向连接可靠的协议流(HTTP)，有以下优点：面向连接、可靠性、RTT(往返连接 Round-Trip Time)和RTO(重传超时 Retransmission TimeOut)、一个数据包从一端发送到另一端收到回包后都会重新计算重传超时时间、数据排序、流量控制(滑动窗口、固定发送频率)、全双工。<br>&emsp;&emsp;UDP:面向无连接的通讯协议(在线视频)。<br>&emsp;&emsp;UDT:基于UDP、在应用层自己实现连接、重传的机制(HTTP3)。</p>
</li>
<li><p>TCP三次握手<br><img src="http://i1.fuimg.com/736325/63be7e99736fa3f3.png"><br>&emsp;&emsp;(1).第一次握手:客户端向服务端发送一个SYN报文(TCP报文中含有SYN标识位的报文、SYN=1 seq= 24316(序列号))、客户端进入存储在TCP中为SYN_SENT状态。<br>&emsp;&emsp;(2).第二次握手:服务收到客户端报文、得知客户端需要建立连接、服务端发出应答报文(SYN=1 ACK=1(标志位)、服务端进入SYN_RECEIVED状态ack=24317(为客户端seq+1、表示服务端收到客户端消息) seq=6478(序列号))。<br>&emsp;&emsp;(3).第三次握手:客户端收到服务端报文、检查 ACK是否等于1 ack是否等于客户端seq+1、而后发送ACK报文(ACK=1 seq=6479)应答服务器、客户端进入连接、服务端收到报文也进入连接状态。</p>
</li>
<li><p>TCP四次挥手<br><img src="http://i1.fuimg.com/736325/a3dcc48b05782959.png"><br>&emsp;&emsp;(1).第一次挥手:客户端向服务端发送一个FIN报文(FIN=1 seq=28356(序列号))、客户端进入FIN_WAIT_1状态(客户端不再发送数据)。<br>&emsp;&emsp;(2).第二次挥手:服务端收到客户端FIN报文、服务端发出应答报文ACK(ACK=1 seq=28357(序列号))，服务端进入CLOSE_WAIT状态(知道客户端不再发数据)，客户端进入FIN_WAIT状态。<br>&emsp;&emsp;(3).第三次挥手:服务端将所有数据发送给客户端后、发送一个FIN(FIN=1 seq=783469)报文通知客户端，服务端进入CLOSE状态。服务端的ACK报文和FIN报文可能合并进行发送(服务端将所有数据发送完毕后)。<br>&emsp;&emsp;(4).第四次挥手:客户端收到服务端FIN报文后进入TIME_WAITING状态，并发出ACK(ACK=1 seq=783470)应答报文，服务端收到客户端应答后进入CLOSED状态。<br>&emsp;&emsp;客户端在进入TIME_WAITING状态后在经过2*MSL(最长报文段寿命，存活最长时间 RFC:2分钟)时间后才会进入CLOSED状态(①传输丢包情况下、保证服务端迟来的报文有足够的时间被识别和解析。②确保可靠的终止TCP/IP连接)。</p>
</li>
</ul>
<h2 id="Socket网络通信"><a href="#Socket网络通信" class="headerlink" title="Socket网络通信"></a>Socket网络通信</h2><p>&emsp;&emsp;Socket是应用层语TCP/IP协议族通信的中间软件抽象层、它是一组接口，其实是一个门面模式。TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫套接字(Socket)。</p>
<h3 id="原生JDK网络编程-BIO"><a href="#原生JDK网络编程-BIO" class="headerlink" title="原生JDK网络编程-BIO"></a>原生JDK网络编程-BIO</h3><p><img src="http://i2.tiimg.com/736325/fa6619ed3dc7ac92.png"><br>&emsp;&emsp;阻塞式网络通讯(socket没有读取到网络数据就阻塞当前线程)。服务端BIO实现:首先创建ServerSocket对象绑定当前端口、启动接口监听，然后接收客户端的连接并返回Socket对象，和客户端连接成功后创建一个新的线程进行阻塞式通信(bind()-&gt;accept()-&gt;开启一个Thread{ Socket-&gt; Write和Read })，accept是一个阻塞方法。客户端:获取服务端IP和端口号并用socket进行连接，然后进行数据的读写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">/** 客户端BIO实现 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketTest</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> socket: Socket) &#123;<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> inetSocketAddress: InetSocketAddress<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> inputStream: ObjectInputStream? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> outStream: ObjectOutputStream? = <span class="hljs-literal">null</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">socketTask</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inetSocketAddress = InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>)<br>            socket.connect(inetSocketAddress)<br>            inputStream = ObjectInputStream(socket.getInputStream())<br>            outStream = ObjectOutputStream(socket.getOutputStream())<br>            outStream?.writeUTF(<span class="hljs-string">&quot;hello&quot;</span>)<br>            outStream?.flush()<br>            inputStream?.readUTF()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            inputStream?.close()<br>            outStream?.close()<br>            socket.close()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="原生JDK网络编程-NIO"><a href="#原生JDK网络编程-NIO" class="headerlink" title="原生JDK网络编程-NIO"></a>原生JDK网络编程-NIO</h3><p><img src="http://i2.tiimg.com/736325/961080d708d48a24.png"><br>&emsp;&emsp;多路复用非阻塞式编程(一个线程服务多个客户端)、其三大核心:Selector选择器、Channel管道和Buffer缓冲区。服务端NIO实现:首先创建Selector对象和ServerSocketChannel对象并、并让ServerSocketChannel在Selector中注册一个关注客户端连接的SelectionKey事件。当有客户端连接进来后，Selector会通知ServerSocketChannel有客户端连接事件而后产生SocketChannel对象，SocketChannel在Selector中注册网络上关注读SelectionKey事件。当客户端往服务器发送数据时，Selector会通知相对应的SocketChannel有读事件进来，SocketChannel获取网络数据后会将数据缓存在Buffer中，然后由Buffer输出到相应的业务逻辑处理程序，当有数据从业务逻辑产生时也会先缓存在Buffer中，在由Buffer输入到SocketChannel中推送给客户端。当有多个客户端连接时，ServerSocketChannel会根据客户端产生相对应的SocketChannel，并注册SelectionKey事件监听网络上的读事件，最后通过Buffer进行数据输入输出。</p>
<ul>
<li><p>三大核心组件<br>&emsp;&emsp;(1).ServerSocketChannel:绑定某个端口并接收连接(对应BIO中的ServerSocket)。<br>&emsp;&emsp;(2).Selector:①ServerSocketChannel在Selector注册客户端的连接SelectionKey事件②客户端连接服务端、Selector感知客户端连接事件后、通知 ServerSocketChannel和客户端进行连接。<br>&emsp;&emsp;(3).SocketChannel:ServerSocketChannel连接成功后产生SocketChannel，并在Selector注册关注读或写的SelectionKey事件(对应BIO中Socket)。</p>
</li>
<li><p>Buffer缓存<br>&emsp;&emsp;客户端请求服务器进行读写时，Selector感知读写事件通知SocketChannel进行读、写并把数据写入Buffer中、逻辑程序在Buffer中读、写。buffer有三个重要属性:capacity、position、limit。Buffer进行数据写入时，position代表内存下一个写入的位置、limit表示可以写入的最大长度(一般来说limit等于capacity)。当SocketChannel从Buffer中读取数据时、Buffer中有个读写模式切换的flip()函数、Buffer切换到读模式position的位置会移动到数据开始位置、而limit则移动到写入数据时position位置、最后将数据从Buffer中读出并写入SocketChannel中。</p>
</li>
</ul>
<p>&emsp;&emsp;客户端实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 享学课堂Mark老师</span><br><span class="hljs-comment"> * 类说明：nio通信客户端处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClientHandle</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> host: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> port: <span class="hljs-built_in">Int</span>) : Runnable &#123;<br>    <span class="hljs-meta">@kotlin</span>.jvm.Volatile<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> started = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> selector: Selector? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> socketChannel: SocketChannel? = <span class="hljs-literal">null</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> &#123;<br>        started = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect()<br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>            e.printStackTrace()<br>            exitProcess(<span class="hljs-number">1</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">/*无论是否有读写事件发生，selector每隔1s被唤醒一次*/</span><br>                selector?.select(<span class="hljs-number">1000</span>)<br>                <span class="hljs-comment">/*获取当前有哪些事件可以使用*/</span><br>                <span class="hljs-keyword">val</span> keys: Set&lt;SelectionKey&gt; = selector?.selectedKeys()?:<span class="hljs-keyword">return</span><br>                <span class="hljs-keyword">val</span> it: Iterator&lt;SelectionKey&gt; = keys.iterator()<br>                <span class="hljs-keyword">var</span> key: SelectionKey? = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>                    key = it.next()<br>                    <span class="hljs-comment">/*我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。如果我们没有删除处理过的键，</span><br><span class="hljs-comment">                    那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它*/</span><br>                    it.remove()<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handleInput(key)<br>                    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                        <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>                            key.cancel()<br>                            <span class="hljs-keyword">if</span> (key.channel() != <span class="hljs-literal">null</span>) &#123;<br>                                key.channel().close()<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                e.printStackTrace()<br>                exitProcess(<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*selector关闭后会自动释放里面管理的资源*/</span><br>        <span class="hljs-keyword">if</span> (selector != <span class="hljs-literal">null</span>) <span class="hljs-keyword">try</span> &#123;<br>            selector?.close()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@kotlin</span>.Throws(IOException::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doConnect</span><span class="hljs-params">()</span></span> &#123;<br>       <span class="hljs-comment">/*connect非阻塞，当他返回的时候，连接不一定完成了，如果返回值为true，表示连接完成、</span><br><span class="hljs-comment">       返回值为false，表示连接没完成，还在三次握手的过程中*/</span><br>        <span class="hljs-keyword">if</span> (socketChannel?.connect(InetSocketAddress(host, port))==<span class="hljs-literal">true</span>) &#123;<br>            socketChannel?.register(selector, SelectionKey.OP_READ)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*selector要告诉我，连接以及完成*/</span><br>            socketChannel?.register(selector, SelectionKey.OP_CONNECT)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@kotlin</span>.Throws(IOException::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(key: <span class="hljs-type">SelectionKey</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (key.isValid) &#123;<br>            <span class="hljs-comment">/*获得关心当前事件的channel*/</span><br>            <span class="hljs-keyword">val</span> sc: SocketChannel = key.channel() <span class="hljs-keyword">as</span> SocketChannel<br>            <span class="hljs-keyword">if</span> (key.isConnectable) &#123;<br>                <span class="hljs-keyword">if</span> (sc.finishConnect()) &#123;<br>                    socketChannel?.register(selector, SelectionKey.OP_READ)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    exitProcess(<span class="hljs-number">1</span>)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (key.isReadable) &#123;<br>                <span class="hljs-comment">/*创建ByteBuffer，并开辟一个1M的缓冲区*/</span><br>                <span class="hljs-keyword">val</span> buffer: ByteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>)<br>                <span class="hljs-comment">/*读取请求码流，返回读取到的字节数*/</span><br>                <span class="hljs-keyword">val</span> readBytes: <span class="hljs-built_in">Int</span> = sc.read(buffer)<br>                <span class="hljs-comment">/*读取到字节，对字节进行编解码*/</span><br>                <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">/*将缓冲区当前的limit设置为position，position=0，用于后续对缓冲区的读取操作*/</span><br>                    buffer.flip()<br>                    <span class="hljs-comment">/*根据缓冲区可读字节数创建字节数组*/</span><br>                    <span class="hljs-keyword">val</span> bytes = ByteArray(buffer.remaining())<br>                    <span class="hljs-comment">/*将缓冲区可读字节数组复制到新建的数组中*/</span><br>                    buffer.<span class="hljs-keyword">get</span>(bytes)<br>                    <span class="hljs-keyword">val</span> result = String(bytes)<br>                    println(<span class="hljs-string">&quot;客户端收到消息：<span class="hljs-variable">$result</span>&quot;</span>)<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                    key.cancel()<br>                    sc.close()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@kotlin</span>.Throws(IOException::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(channel: <span class="hljs-type">SocketChannel</span>?, request: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-comment">/*将消息编码为字节数组*/</span><br>        <span class="hljs-keyword">val</span> bytes: ByteArray = request.toByteArray()<br>        <span class="hljs-comment">/*根据数组容量创建ByteBuffer*/</span><br>        <span class="hljs-keyword">val</span> writeBuffer: ByteBuffer = ByteBuffer.allocate(bytes.size)<br>        <span class="hljs-comment">/*将字节数组复制到缓冲区*/</span><br>        writeBuffer.put(bytes)<br>        writeBuffer.flip()<br>        <span class="hljs-comment">/*发送缓冲区的字节数组、关心事件和读写网络并不冲突*/</span><br>        channel?.write(writeBuffer)<br>    &#125;<br><br>    <span class="hljs-comment">/*写数据对外暴露的API*/</span><br>    <span class="hljs-meta">@kotlin</span>.Throws(Exception::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(msg: <span class="hljs-type">String</span>)</span></span> &#123;<br>        doWrite(socketChannel, msg)<br>    &#125;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/*创建选择器的实例*/</span><br>            selector = Selector.<span class="hljs-keyword">open</span>()<br>            <span class="hljs-comment">/*创建ServerSocketChannel的实例*/</span><br>            socketChannel = SocketChannel.<span class="hljs-keyword">open</span>()<br>            <span class="hljs-comment">/*设置通道为非阻塞模式*/</span><br>            socketChannel?.configureBlocking(<span class="hljs-literal">false</span>)<br>            started = <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Okhttp源码分析"><a href="#Okhttp源码分析" class="headerlink" title="Okhttp源码分析"></a>Okhttp源码分析</h1><p>&emsp;&emsp;OkHttp是当下Android使用最频繁的网络请求框架，由Square公司开源。Google在Android4.4以后开始将源码中的HttpURLConnection底层实现替换为OKHttp，同时现在流行的Retrofit框架底层同样是使用OKHttp的。优点如下:①支持Http1、Http2、Quic以及WebSocket。②支持HTTP/2并允许对同一主机的所有请求共享一个套接字。③无缝的支持GZIP减少数据流量。④缓存响应数据减少重复的网络请求。⑤请求失败自动重试主机的其他ip，自动重定向。</p>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>&emsp;&emsp;首先创建OkhttpClient对象、有两种方式获得(直接通过new方式创建或通过构建者模式创建)，接着构建者模式创建请求的Request、若为Post请求则需添加RequestBody参数，通过OkhttpClient创建一个真实请求的call，最后进行同步或异步请求，使用如下示:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">okhttpTest</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> okHttpClient = OkHttpClient()<br>    <span class="hljs-comment">/* 通过构建者模式创建OkhttpClient */</span><br>    <span class="hljs-keyword">val</span> okHttpClient2 = OkHttpClient.Builder().build()<br><br>    <span class="hljs-keyword">val</span> request = Request.Builder().url(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).build()<br>    <span class="hljs-comment">/*发送Post请求、请求参数转换成表单形式*/</span><br>    <span class="hljs-keyword">val</span> requestBody = FormBody.Builder().add(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-string">&quot;135679&quot;</span>).build() <span class="hljs-keyword">as</span> RequestBody<br>    <span class="hljs-keyword">val</span> request2 = Request.Builder().url(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).post(requestBody).build()<br><br>    <span class="hljs-keyword">val</span> call = okHttpClient.newCall(request)<br>    <span class="hljs-keyword">val</span> call2 = okHttpClient2.newCall(request2)<br><br>    <span class="hljs-comment">/*同步请求*/</span><br>    call.execute()<br>    call2.execute()<br><br>    <span class="hljs-comment">/*异步请求*/</span><br>    call.enqueue(<span class="hljs-keyword">object</span> : Callback &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, e: <span class="hljs-type">IOException</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>        &#125;<br>    &#125;)<br>    call2.enqueue(<span class="hljs-keyword">object</span> : Callback &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, e: <span class="hljs-type">IOException</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&emsp;&emsp;OkhttpClient通过Builder模式来配置自定义Client、Request也可以通过Builder模式配置请求所需参数，而后通过OkhttpClient的newCall()函数得到真实网络请求的Call，分析newCall函数可知在OkhttpClient直接new了一个ReallCall:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* Prepares the [request] to be executed at some point in the future. */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newCall</span><span class="hljs-params">(request: <span class="hljs-type">Request</span>)</span></span>: Call = RealCall(<span class="hljs-keyword">this</span>, request, forWebSocket = <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过分析可知真正发起网络请求的是RealCall对象，分析RealCall发起请求enqueue()函数或execute()函数可知Call发起请求最终由Dispatcher进行分发处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(responseCallback: <span class="hljs-type">Callback</span>)</span></span> &#123;<br>  <span class="hljs-comment">/*判断是否执行过请求网络、若执行过则抛出异常*/</span><br>  check(executed.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123; <span class="hljs-string">&quot;Already Executed&quot;</span> &#125;<br><br>  callStart()<br>  <span class="hljs-comment">/*创建一个异步任务AsyncCall并丢入Dispatcher中*/</span><br>  client.dispatcher.enqueue(AsyncCall(responseCallback))<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="分发器Dispatcher"><a href="#分发器Dispatcher" class="headerlink" title="分发器Dispatcher"></a>分发器Dispatcher</h2><p>&emsp;&emsp;在配置OkhttpClient时，若没有传入自定义分发器则使用默认分发器。分发器就是来调配请求任务的，内部会包含一个线程池。可以在创建OkHttpClient时，传递我们自己定义的线程池来创建分发器。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Network" >
    <span class="tag-code">Network</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/04/19/handle/">
        <span class="nav-arrow">← </span>
        
          消息机制
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">导航</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-nav-text">计算机网络基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-nav-text">计算机网络体系结构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-nav-text">TCP&#x2F;IP协议族</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-nav-text">Socket网络通信</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8E%9F%E7%94%9FJDK%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-BIO"><span class="toc-nav-text">原生JDK网络编程-BIO</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8E%9F%E7%94%9FJDK%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-NIO"><span class="toc-nav-text">原生JDK网络编程-NIO</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Okhttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-nav-text">Okhttp源码分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">请求流程</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%88%86%E5%8F%91%E5%99%A8Dispatcher"><span class="toc-nav-text">分发器Dispatcher</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://example.com/2021/04/20/network/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>



  <script>
    var gitmentConfig = "MilkBeeno";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "客户端网络通信",
        owner: "MilkBeeno",
        repo: "https://github.com/MilkBeeno",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>



  </body>
</html>