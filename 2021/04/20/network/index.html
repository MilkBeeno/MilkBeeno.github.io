<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="MilkeBeeno&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      客户端网络通信 | MilkBeeno
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 5.4.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>MilkBeeno</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">项目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">作者</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">项目</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">作者</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>客户端网络通信</h2>
  <p class="post-date">2021-04-20</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="一、计算机网络基础"><a href="#一、计算机网络基础" class="headerlink" title="一、计算机网络基础"></a>一、计算机网络基础</h1><p>&emsp;&emsp;计算机网络学习的核心内容就是网络协议的学习，网络协议是为计算机网络中进行数据交换而建立的规则、标准或者说是约定的集合。作为Android开发工程师必须掌握基础的网络相关知识，主要涵盖TCP/IP协议、UDP协议、HTTP协议和Socket等。</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><table>
<thead>
<tr>
<th>TCP/IP模型</th>
<th>OSI模型</th>
<th>TCP/IP协议族</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>应用层</td>
<td>TFTP、HTTP、SNMP、FTP、DNS、Telnet</td>
<td>文件传输、电子邮件、文件服务、虚拟终端</td>
</tr>
<tr>
<td>应用层</td>
<td>表示层</td>
<td></td>
<td>数据格式转换、代码转换、数据加密</td>
</tr>
<tr>
<td></td>
<td>会话层</td>
<td></td>
<td>接触或建立与别的接点的联系</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>TCP、UDP</td>
<td>提供端对端的接口</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>IP、ICMP、RIP、OSPF、BGP、IGMP</td>
<td>为数据包选择路由</td>
</tr>
<tr>
<td>链路层</td>
<td>链路层</td>
<td>SLIP、CSLIP、PPP、ARP、PARP、MTU</td>
<td>传输有地址的帧以及错误检测功能</td>
</tr>
<tr>
<td></td>
<td>物理层</td>
<td></td>
<td>以二进制数据形式在物理媒体上传输数据</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;网络数据的传输是以包的形式进行，其工作流程就是拼包和拆包。在数据传输过程中，包是全能性术语，除此还有帧用于表示数据链路层中包的单位、片是IP中数据的单位、段则表示TCP数据流中的信息、消息表示应用协议中数据的单位。首先在应用层获取应用协议传过来的数据、经过传输层附加TCP包首部、经过网络层附加IP包首部、再经过数据链路层附加以太网包首部、最后经过物理层传输到达目标点进行逆向解包，最终展示给用户。</p>
<h2 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h2><p>&emsp;&emsp;TCP/IP协议簇是Internet的基础，也是当今最流行的组网形式。TCP/IP是一组协议的代名词，包括许多别的协议，组成了TCP/IP协议簇。其中比较重要的有SLIP协议、PPP协议、IP协议、ICMP协议、ARP协议、TCP协议、UDP协议、FTP协议、DNS协议、SMTP协议等。</p>
<ul>
<li><p>协议介绍<br>&emsp;&emsp;TCP:面向连接可靠的协议流(HTTP)，有以下优点：面向连接、可靠性、RTT(往返连接 Round-Trip Time)和RTO(重传超时 Retransmission TimeOut)、一个数据包从一端发送到另一端收到回包后都会重新计算重传超时时间、数据排序、流量控制(滑动窗口、固定发送频率)、全双工。<br>&emsp;&emsp;UDP:面向无连接的通讯协议(在线视频)。<br>&emsp;&emsp;UDT:基于UDP、在应用层自己实现连接、重传的机制(HTTP3)。</p>
</li>
<li><p>TCP三次握手<br><img src="https://raw.githubusercontent.com/MilkBeeno/MilkBeeno.github.io.picture/master/2021/network_1.png"><br>&emsp;&emsp;(1).第一次握手:客户端向服务端发送一个SYN报文(TCP报文中含有SYN标识位的报文、SYN=1 seq= 24316(序列号))、客户端进入存储在TCP中为SYN_SENT状态。<br>&emsp;&emsp;(2).第二次握手:服务收到客户端报文、得知客户端需要建立连接、服务端发出应答报文(SYN=1 ACK=1(标志位)、服务端进入SYN_RECEIVED状态ack=24317(为客户端seq+1、表示服务端收到客户端消息) seq=6478(序列号))。<br>&emsp;&emsp;(3).第三次握手:客户端收到服务端报文、检查 ACK是否等于1 ack是否等于客户端seq+1、而后发送ACK报文(ACK=1 seq=6479)应答服务器、客户端进入连接、服务端收到报文也进入连接状态。</p>
</li>
<li><p>TCP四次挥手<br><img src="https://raw.githubusercontent.com/MilkBeeno/MilkBeeno.github.io.picture/master/2021/network_2.png"><br>&emsp;&emsp;(1).第一次挥手:客户端向服务端发送一个FIN报文(FIN=1 seq=28356(序列号))、客户端进入FIN_WAIT_1状态(客户端不再发送数据)。<br>&emsp;&emsp;(2).第二次挥手:服务端收到客户端FIN报文、服务端发出应答报文ACK(ACK=1 seq=28357(序列号))，服务端进入CLOSE_WAIT状态(知道客户端不再发数据)，客户端进入FIN_WAIT状态。<br>&emsp;&emsp;(3).第三次挥手:服务端将所有数据发送给客户端后、发送一个FIN(FIN=1 seq=783469)报文通知客户端，服务端进入CLOSE状态。服务端的ACK报文和FIN报文可能合并进行发送(服务端将所有数据发送完毕后)。<br>&emsp;&emsp;(4).第四次挥手:客户端收到服务端FIN报文后进入TIME_WAITING状态，并发出ACK(ACK=1 seq=783470)应答报文，服务端收到客户端应答后进入CLOSED状态。<br>&emsp;&emsp;客户端在进入TIME_WAITING状态后在经过2*MSL(最长报文段寿命，存活最长时间 RFC:2分钟)时间后才会进入CLOSED状态(①传输丢包情况下、保证服务端迟来的报文有足够的时间被识别和解析。②确保可靠的终止TCP/IP连接)。</p>
</li>
</ul>
<h2 id="Socket网络通信"><a href="#Socket网络通信" class="headerlink" title="Socket网络通信"></a>Socket网络通信</h2><p>&emsp;&emsp;Socket是应用层语TCP/IP协议族通信的中间软件抽象层、它是一组接口，其实是一个门面模式。TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫套接字(Socket)。</p>
<h3 id="原生JDK网络编程-BIO"><a href="#原生JDK网络编程-BIO" class="headerlink" title="原生JDK网络编程-BIO"></a>原生JDK网络编程-BIO</h3><p><img src="https://raw.githubusercontent.com/MilkBeeno/MilkBeeno.github.io.picture/master/2021/network_3.png"><br>&emsp;&emsp;阻塞式网络通讯(socket没有读取到网络数据就阻塞当前线程)。服务端BIO实现:首先创建ServerSocket对象绑定当前端口、启动接口监听，然后接收客户端的连接并返回Socket对象，和客户端连接成功后创建一个新的线程进行阻塞式通信(bind()-&gt;accept()-&gt;开启一个Thread{ Socket-&gt; Write和Read })，accept是一个阻塞方法。客户端:获取服务端IP和端口号并用socket进行连接，然后进行数据的读写。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">/** 客户端BIO实现 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketTest</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> socket: Socket) &#123;<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> inetSocketAddress: InetSocketAddress<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> inputStream: ObjectInputStream? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> outStream: ObjectOutputStream? = <span class="hljs-literal">null</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">socketTask</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inetSocketAddress = InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>)<br>            socket.connect(inetSocketAddress)<br>            inputStream = ObjectInputStream(socket.getInputStream())<br>            outStream = ObjectOutputStream(socket.getOutputStream())<br>            outStream?.writeUTF(<span class="hljs-string">&quot;hello&quot;</span>)<br>            outStream?.flush()<br>            inputStream?.readUTF()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            inputStream?.close()<br>            outStream?.close()<br>            socket.close()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="原生JDK网络编程-NIO"><a href="#原生JDK网络编程-NIO" class="headerlink" title="原生JDK网络编程-NIO"></a>原生JDK网络编程-NIO</h3><p><img src="https://raw.githubusercontent.com/MilkBeeno/MilkBeeno.github.io.picture/master/2021/network_4.png"><br>&emsp;&emsp;多路复用非阻塞式编程(一个线程服务多个客户端)、其三大核心:Selector选择器、Channel管道和Buffer缓冲区。服务端NIO实现:首先创建Selector对象和ServerSocketChannel对象并、并让ServerSocketChannel在Selector中注册一个关注客户端连接的SelectionKey事件。当有客户端连接进来后，Selector会通知ServerSocketChannel有客户端连接事件而后产生SocketChannel对象，SocketChannel在Selector中注册网络上关注读SelectionKey事件。当客户端往服务器发送数据时，Selector会通知相对应的SocketChannel有读事件进来，SocketChannel获取网络数据后会将数据缓存在Buffer中，然后由Buffer输出到相应的业务逻辑处理程序，当有数据从业务逻辑产生时也会先缓存在Buffer中，在由Buffer输入到SocketChannel中推送给客户端。当有多个客户端连接时，ServerSocketChannel会根据客户端产生相对应的SocketChannel，并注册SelectionKey事件监听网络上的读事件，最后通过Buffer进行数据输入输出。</p>
<ul>
<li><p>三大核心组件<br>&emsp;&emsp;(1).ServerSocketChannel:绑定某个端口并接收连接(对应BIO中的ServerSocket)。<br>&emsp;&emsp;(2).Selector:①ServerSocketChannel在Selector注册客户端的连接SelectionKey事件②客户端连接服务端、Selector感知客户端连接事件后、通知 ServerSocketChannel和客户端进行连接。<br>&emsp;&emsp;(3).SocketChannel:ServerSocketChannel连接成功后产生SocketChannel，并在Selector注册关注读或写的SelectionKey事件(对应BIO中Socket)。</p>
</li>
<li><p>Buffer缓存<br>&emsp;&emsp;客户端请求服务器进行读写时，Selector感知读写事件通知SocketChannel进行读、写并把数据写入Buffer中、逻辑程序在Buffer中读、写。buffer有三个重要属性:capacity、position、limit。Buffer进行数据写入时，position代表内存下一个写入的位置、limit表示可以写入的最大长度(一般来说limit等于capacity)。当SocketChannel从Buffer中读取数据时、Buffer中有个读写模式切换的flip()函数、Buffer切换到读模式position的位置会移动到数据开始位置、而limit则移动到写入数据时position位置、最后将数据从Buffer中读出并写入SocketChannel中。</p>
</li>
</ul>
<p>&emsp;&emsp;客户端实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 享学课堂Mark老师</span><br><span class="hljs-comment"> * 类说明：nio通信客户端处理器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClientHandle</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> host: String, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> port: <span class="hljs-built_in">Int</span>) : Runnable &#123;<br>    <span class="hljs-meta">@kotlin</span>.jvm.Volatile<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> started = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> selector: Selector? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> socketChannel: SocketChannel? = <span class="hljs-literal">null</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span> &#123;<br>        started = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect()<br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>            e.printStackTrace()<br>            exitProcess(<span class="hljs-number">1</span>)<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">/*无论是否有读写事件发生，selector每隔1s被唤醒一次*/</span><br>                selector?.select(<span class="hljs-number">1000</span>)<br>                <span class="hljs-comment">/*获取当前有哪些事件可以使用*/</span><br>                <span class="hljs-keyword">val</span> keys: Set&lt;SelectionKey&gt; = selector?.selectedKeys()?:<span class="hljs-keyword">return</span><br>                <span class="hljs-keyword">val</span> it: Iterator&lt;SelectionKey&gt; = keys.iterator()<br>                <span class="hljs-keyword">var</span> key: SelectionKey? = <span class="hljs-literal">null</span><br>                <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>                    key = it.next()<br>                    <span class="hljs-comment">/*我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。如果我们没有删除处理过的键，</span><br><span class="hljs-comment">                    那么它仍然会在主集合中以一个激活的键出现，这会导致我们尝试再次处理它*/</span><br>                    it.remove()<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handleInput(key)<br>                    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                        <span class="hljs-keyword">if</span> (key != <span class="hljs-literal">null</span>) &#123;<br>                            key.cancel()<br>                            <span class="hljs-keyword">if</span> (key.channel() != <span class="hljs-literal">null</span>) &#123;<br>                                key.channel().close()<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>                e.printStackTrace()<br>                exitProcess(<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*selector关闭后会自动释放里面管理的资源*/</span><br>        <span class="hljs-keyword">if</span> (selector != <span class="hljs-literal">null</span>) <span class="hljs-keyword">try</span> &#123;<br>            selector?.close()<br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@kotlin</span>.Throws(IOException::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doConnect</span><span class="hljs-params">()</span></span> &#123;<br>       <span class="hljs-comment">/*connect非阻塞，当他返回的时候，连接不一定完成了，如果返回值为true，表示连接完成、</span><br><span class="hljs-comment">       返回值为false，表示连接没完成，还在三次握手的过程中*/</span><br>        <span class="hljs-keyword">if</span> (socketChannel?.connect(InetSocketAddress(host, port))==<span class="hljs-literal">true</span>) &#123;<br>            socketChannel?.register(selector, SelectionKey.OP_READ)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*selector要告诉我，连接以及完成*/</span><br>            socketChannel?.register(selector, SelectionKey.OP_CONNECT)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@kotlin</span>.Throws(IOException::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(key: <span class="hljs-type">SelectionKey</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (key.isValid) &#123;<br>            <span class="hljs-comment">/*获得关心当前事件的channel*/</span><br>            <span class="hljs-keyword">val</span> sc: SocketChannel = key.channel() <span class="hljs-keyword">as</span> SocketChannel<br>            <span class="hljs-keyword">if</span> (key.isConnectable) &#123;<br>                <span class="hljs-keyword">if</span> (sc.finishConnect()) &#123;<br>                    socketChannel?.register(selector, SelectionKey.OP_READ)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    exitProcess(<span class="hljs-number">1</span>)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (key.isReadable) &#123;<br>                <span class="hljs-comment">/*创建ByteBuffer，并开辟一个1M的缓冲区*/</span><br>                <span class="hljs-keyword">val</span> buffer: ByteBuffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>)<br>                <span class="hljs-comment">/*读取请求码流，返回读取到的字节数*/</span><br>                <span class="hljs-keyword">val</span> readBytes: <span class="hljs-built_in">Int</span> = sc.read(buffer)<br>                <span class="hljs-comment">/*读取到字节，对字节进行编解码*/</span><br>                <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">/*将缓冲区当前的limit设置为position，position=0，用于后续对缓冲区的读取操作*/</span><br>                    buffer.flip()<br>                    <span class="hljs-comment">/*根据缓冲区可读字节数创建字节数组*/</span><br>                    <span class="hljs-keyword">val</span> bytes = ByteArray(buffer.remaining())<br>                    <span class="hljs-comment">/*将缓冲区可读字节数组复制到新建的数组中*/</span><br>                    buffer.<span class="hljs-keyword">get</span>(bytes)<br>                    <span class="hljs-keyword">val</span> result = String(bytes)<br>                    println(<span class="hljs-string">&quot;客户端收到消息：<span class="hljs-variable">$result</span>&quot;</span>)<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                    key.cancel()<br>                    sc.close()<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@kotlin</span>.Throws(IOException::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(channel: <span class="hljs-type">SocketChannel</span>?, request: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-comment">/*将消息编码为字节数组*/</span><br>        <span class="hljs-keyword">val</span> bytes: ByteArray = request.toByteArray()<br>        <span class="hljs-comment">/*根据数组容量创建ByteBuffer*/</span><br>        <span class="hljs-keyword">val</span> writeBuffer: ByteBuffer = ByteBuffer.allocate(bytes.size)<br>        <span class="hljs-comment">/*将字节数组复制到缓冲区*/</span><br>        writeBuffer.put(bytes)<br>        writeBuffer.flip()<br>        <span class="hljs-comment">/*发送缓冲区的字节数组、关心事件和读写网络并不冲突*/</span><br>        channel?.write(writeBuffer)<br>    &#125;<br><br>    <span class="hljs-comment">/*写数据对外暴露的API*/</span><br>    <span class="hljs-meta">@kotlin</span>.Throws(Exception::<span class="hljs-class"><span class="hljs-keyword">class</span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(msg: <span class="hljs-type">String</span>)</span></span> &#123;<br>        doWrite(socketChannel, msg)<br>    &#125;<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/*创建选择器的实例*/</span><br>            selector = Selector.<span class="hljs-keyword">open</span>()<br>            <span class="hljs-comment">/*创建ServerSocketChannel的实例*/</span><br>            socketChannel = SocketChannel.<span class="hljs-keyword">open</span>()<br>            <span class="hljs-comment">/*设置通道为非阻塞模式*/</span><br>            socketChannel?.configureBlocking(<span class="hljs-literal">false</span>)<br>            started = <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="二、Okhttp源码分析"><a href="#二、Okhttp源码分析" class="headerlink" title="二、Okhttp源码分析"></a>二、Okhttp源码分析</h1><p>&emsp;&emsp;OkHttp是当下Android使用最频繁的网络请求框架，由Square公司开源。Google在Android4.4以后开始将源码中的HttpURLConnection底层实现替换为OKHttp，同时现在流行的Retrofit框架底层同样是使用OKHttp的。优点如下:①支持Http1、Http2、Quic以及WebSocket。②支持HTTP/2并允许对同一主机的所有请求共享一个套接字。③无缝的支持GZIP减少数据流量。④缓存响应数据减少重复的网络请求。⑤请求失败自动重试主机的其他ip，自动重定向。</p>
<h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>&emsp;&emsp;首先创建OkhttpClient对象、有两种方式获得(直接通过new方式创建或通过构建者模式创建)，接着构建者模式创建请求的Request、若为Post请求则需添加RequestBody参数，通过OkhttpClient创建一个真实请求的call，最后进行同步或异步请求使用如下示:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">okhttpTest</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> okHttpClient = OkHttpClient()<br>    <span class="hljs-comment">/* 通过构建者模式创建OkhttpClient */</span><br>    <span class="hljs-keyword">val</span> okHttpClient2 = OkHttpClient.Builder().build()<br><br>    <span class="hljs-keyword">val</span> request = Request.Builder().url(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).build()<br>    <span class="hljs-comment">/*发送Post请求、请求参数转换成表单形式*/</span><br>    <span class="hljs-keyword">val</span> requestBody = FormBody.Builder().add(<span class="hljs-string">&quot;userId&quot;</span>, <span class="hljs-string">&quot;135679&quot;</span>).build() <span class="hljs-keyword">as</span> RequestBody<br>    <span class="hljs-keyword">val</span> request2 = Request.Builder().url(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).post(requestBody).build()<br><br>    <span class="hljs-keyword">val</span> call = okHttpClient.newCall(request)<br>    <span class="hljs-keyword">val</span> call2 = okHttpClient2.newCall(request2)<br><br>    <span class="hljs-comment">/*同步请求*/</span><br>    call.execute()<br>    call2.execute()<br><br>    <span class="hljs-comment">/*异步请求*/</span><br>    call.enqueue(<span class="hljs-keyword">object</span> : Callback &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, e: <span class="hljs-type">IOException</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>        &#125;<br>    &#125;)<br>    call2.enqueue(<span class="hljs-keyword">object</span> : Callback &#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, e: <span class="hljs-type">IOException</span>)</span></span> &#123;<br>        &#125;<br><br>        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onResponse</span><span class="hljs-params">(call: <span class="hljs-type">Call</span>, response: <span class="hljs-type">Response</span>)</span></span> &#123;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&emsp;&emsp;OkhttpClient通过Builder模式来配置自定义Client、Request也可以通过Builder模式配置请求所需参数，而后通过OkhttpClient的newCall()函数得到真实网络请求的Call，分析newCall函数可知在OkhttpClient直接new了一个ReallCall:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* Prepares the [request] to be executed at some point in the future. */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">newCall</span><span class="hljs-params">(request: <span class="hljs-type">Request</span>)</span></span>: Call = RealCall(<span class="hljs-keyword">this</span>, request, forWebSocket = <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过分析可知真正发起网络请求的是RealCall对象，分析RealCall发起请求enqueue()函数或execute()函数可知Call发起请求最终由Dispatcher进行分发处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* enqueue异步请求 */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(responseCallback: <span class="hljs-type">Callback</span>)</span></span> &#123;<br>  <span class="hljs-comment">/*判断是否执行过请求网络、若执行过则抛出异常*/</span><br>  check(executed.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123; <span class="hljs-string">&quot;Already Executed&quot;</span> &#125;<br>  callStart()<br>  <span class="hljs-comment">/*创建一个异步任务AsyncCall并丢入Dispatcher中*/</span><br>  client.dispatcher.enqueue(AsyncCall(responseCallback))<br>&#125;<br><span class="hljs-comment">/* execute同步请求 */</span><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>: Response &#123;<br>   check(executed.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123; <span class="hljs-string">&quot;Already Executed&quot;</span> &#125;<br>   timeout.enter()<br>   callStart()<br>   <span class="hljs-keyword">try</span> &#123;<br>     client.dispatcher.executed(<span class="hljs-keyword">this</span>)<br>     <span class="hljs-keyword">return</span> getResponseWithInterceptorChain()<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>     client.dispatcher.finished(<span class="hljs-keyword">this</span>)<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h2 id="分发器Dispatcher"><a href="#分发器Dispatcher" class="headerlink" title="分发器Dispatcher"></a>分发器Dispatcher</h2><p>&emsp;&emsp;在配置OkhttpClient时，若没有传入自定义分发器则使用默认分发器。分发器就是来调配请求任务的，内部会包含一个线程池。可以在创建OkHttpClient时，传递我们自己定义的线程池来创建分发器。分发器进行网络数据请求时有execute同步请求和enqueue异步请求两种方式，在分析Dispatcher两种分发处理方式时，我们先要知道Dispatcher以下成员属性：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* 异步请求同时存在的最大请求 */</span><br><span class="hljs-meta">@get:Synchronized</span> <span class="hljs-keyword">var</span> maxRequests = <span class="hljs-number">64</span><br>  <span class="hljs-keyword">set</span>(maxRequests) &#123;<br>    require(maxRequests &gt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-string">&quot;max &lt; 1: <span class="hljs-variable">$maxRequests</span>&quot;</span> &#125;<br>    synchronized(<span class="hljs-keyword">this</span>) &#123;<br>      field = maxRequests<br>    &#125;<br>    promoteAndExecute()<br>  &#125;<br><br><span class="hljs-comment">/* 异步请求同一域名存在的最大请求 */</span><br><span class="hljs-meta">@get:Synchronized</span> <span class="hljs-keyword">var</span> maxRequestsPerHost = <span class="hljs-number">5</span><br>    <span class="hljs-keyword">set</span>(maxRequestsPerHost) &#123;<br>      require(maxRequestsPerHost &gt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-string">&quot;max &lt; 1: <span class="hljs-variable">$maxRequestsPerHost</span>&quot;</span> &#125;<br>      synchronized(<span class="hljs-keyword">this</span>) &#123;<br>        field = maxRequestsPerHost<br>      &#125;<br>      promoteAndExecute()<br>    &#125;<br><br><span class="hljs-comment">/* 闲置任务、没有请求时可执行一些任务、由使用者设置 */</span><br><span class="hljs-meta">@set:Synchronized</span><br><span class="hljs-meta">@get:Synchronized</span><br><span class="hljs-keyword">var</span> idleCallback: Runnable? = <span class="hljs-literal">null</span>  <br><br><span class="hljs-comment">/* 异步请求使用的线程池 */</span><br><span class="hljs-meta">@get:Synchronized</span><br>  <span class="hljs-meta">@get:JvmName</span>(<span class="hljs-string">&quot;executorService&quot;</span>) <span class="hljs-keyword">val</span> executorService: ExecutorService<br>    <span class="hljs-keyword">get</span>() &#123;<br>      <span class="hljs-keyword">if</span> (executorServiceOrNull == <span class="hljs-literal">null</span>) &#123;<br>        executorServiceOrNull = ThreadPoolExecutor(<span class="hljs-number">0</span>, <span class="hljs-built_in">Int</span>.MAX_VALUE, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>            SynchronousQueue(), threadFactory(<span class="hljs-string">&quot;<span class="hljs-variable">$okHttpName</span> Dispatcher&quot;</span>, <span class="hljs-literal">false</span>))<br>      &#125;<br>      <span class="hljs-keyword">return</span> executorServiceOrNull!!<br>    &#125;<br><br><span class="hljs-comment">/* 异步请求等待执行队列 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> readyAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()<br><br><span class="hljs-comment">/* 异步请求正在执行队列 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> runningAsyncCalls = ArrayDeque&lt;AsyncCall&gt;()<br><br><span class="hljs-comment">/* 同步请求正在执行队列 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> runningSyncCalls = ArrayDeque&lt;RealCall&gt;()<br></code></pre></td></tr></table></figure>

<h3 id="execute同步请求"><a href="#execute同步请求" class="headerlink" title="execute同步请求"></a>execute同步请求</h3><p>&emsp;&emsp;因为同步请求不需要线程池，也不存在任何限制，所以分发器仅做一下记录。从RealCall的execute函数可知当Dispatcher进行executed后便调用getResponseWithInterceptorChain()进行网络请求，当网络请求结束后将当前的realCall从同步执行队列中移除。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/* Used by [Call.execute] to signal it is in-flight. */</span><br><span class="hljs-meta">@Synchronized</span> <span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">executed</span><span class="hljs-params">(call: <span class="hljs-type">RealCall</span>)</span></span> &#123;<br>  runningSyncCalls.add(call)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="enqueue异步请求"><a href="#enqueue异步请求" class="headerlink" title="enqueue异步请求"></a>enqueue异步请求</h3><p>&emsp;&emsp;执行异步请求时会创建一个AsyncCall并放入Dispatcher中，将AsycCall加入到等待队列中并遍历runningAsyncCalls和readyAsyncCalls队列，获取和当前AsyncCall相同Host的AsyncCall返回并记录任务数量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(call: <span class="hljs-type">AsyncCall</span>)</span></span> &#123;<br>    synchronized(<span class="hljs-keyword">this</span>) &#123;<br>      readyAsyncCalls.add(call)<br>      <span class="hljs-comment">/* Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to the same host.*/</span><br>      <span class="hljs-keyword">if</span> (!call.call.forWebSocket) &#123;<br>        <span class="hljs-keyword">val</span> existingCall = findExistingCallWithHost(call.host)<br>        <span class="hljs-keyword">if</span> (existingCall != <span class="hljs-literal">null</span>) call.reuseCallsPerHostFrom(existingCall)<br>      &#125;<br>    &#125;<br>    promoteAndExecute()<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后对readyAsyncCalls队列中的任务进行筛选，筛选出可执行的任务进行网络请求处理。任务筛选处理分三步：①当前正在执行的异步请求任务数是否达到最大限制数、若达到则结束此次筛选。②和当前任务相同Host的任务数量超过最大限制、则继续筛选下一个任务。③成功筛选出可执行的任务加入runningAsyncCalls队列和本地可执行任务集合中、并从readyAsyncCalls队列中移除，将可执行任务放到线程池中进行处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">promoteAndExecute</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>   <span class="hljs-keyword">this</span>.assertThreadDoesntHoldLock()<br>   <span class="hljs-keyword">val</span> executableCalls = mutableListOf&lt;AsyncCall&gt;()<br>   <span class="hljs-keyword">val</span> isRunning: <span class="hljs-built_in">Boolean</span><br>   synchronized(<span class="hljs-keyword">this</span>) &#123;<br>     <span class="hljs-keyword">val</span> i = readyAsyncCalls.iterator()<br>     <span class="hljs-keyword">while</span> (i.hasNext()) &#123;<br>       <span class="hljs-keyword">val</span> asyncCall = i.next()<br>       <span class="hljs-comment">/* 判断是否达到最大请求数量 */</span><br>       <span class="hljs-keyword">if</span> (runningAsyncCalls.size &gt;= <span class="hljs-keyword">this</span>.maxRequests) <span class="hljs-keyword">break</span><br>       <span class="hljs-comment">/* 判断请求统一Host主机是否达到最大值5个 */</span><br>       <span class="hljs-keyword">if</span> (asyncCall.callsPerHost.<span class="hljs-keyword">get</span>() &gt;= <span class="hljs-keyword">this</span>.maxRequestsPerHost) <span class="hljs-keyword">continue</span><br>       i.remove()<br>       asyncCall.callsPerHost.incrementAndGet()<br>       executableCalls.add(asyncCall)<br>       runningAsyncCalls.add(asyncCall)<br>     &#125;<br>     isRunning = runningCallsCount() &gt; <span class="hljs-number">0</span><br>   &#125;<br>   <span class="hljs-comment">/* 将可执行任务放入线程池进行处理 */</span><br>   <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> until executableCalls.size) &#123;<br>     <span class="hljs-keyword">val</span> asyncCall = executableCalls[i]<br>     asyncCall.executeOn(executorService)<br>   &#125;<br>   <span class="hljs-keyword">return</span> isRunning<br> &#125;<br></code></pre></td></tr></table></figure>

<p>&emsp;&emsp;AsyncCall是一个Runnable、在run()函数中调用getResponseWithInterceptorChain()方法完成网络请求，分析executeOn()函数和run()函数无论结果如何、都将调用finished()方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> <span class="hljs-title">finished</span><span class="hljs-params">(calls: <span class="hljs-type">Deque</span>&lt;<span class="hljs-type">T</span>&gt;, call: <span class="hljs-type">T</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> idleCallback: Runnable?<br>    synchronized(<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-comment">/* 无论同步请求还是异步请求、执行完都要从队列中移除(runningSyncCalls/runningAsyncCalls) */</span><br>      <span class="hljs-keyword">if</span> (!calls.remove(call)) <span class="hljs-keyword">throw</span> AssertionError(<span class="hljs-string">&quot;Call wasn&#x27;t in-flight!&quot;</span>)<br>      idleCallback = <span class="hljs-keyword">this</span>.idleCallback<br>    &#125;<br>    <span class="hljs-keyword">val</span> isRunning = promoteAndExecute()<br>    <span class="hljs-comment">/* 没有任务执行就执行闲置任务 */</span><br>    <span class="hljs-keyword">if</span> (!isRunning &amp;&amp; idleCallback != <span class="hljs-literal">null</span>) &#123;<br>      idleCallback.run()<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>&emsp;&emsp;OkHttp最核心的工作是在getResponseWithInterceptorChain()中进行，而整个过程使用责任链设计模式：为请求创建了一个接收者对象的链，这种模式给予请求的类型对请求的发送者和接收者进行解耦。在这种模式中通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者、依此类推，默认情况下有五大拦截器。<br>拦截器流程图<br><img src="https://raw.githubusercontent.com/MilkBeeno/MilkBeeno.github.io.picture/master/2021/network_5.png"></p>
<h3 id="RetryAndFollowUpInterceptor-重试、重定向拦截器"><a href="#RetryAndFollowUpInterceptor-重试、重定向拦截器" class="headerlink" title="RetryAndFollowUpInterceptor(重试、重定向拦截器)"></a>RetryAndFollowUpInterceptor(重试、重定向拦截器)</h3><p>&emsp;&emsp;第一个接触到请求最后接触到响应，负责判断是否需要重新发起整个请求。此拦截器未对Request进行参数配置，当请求发生RouteException或IOException异常时会进行重试，并对结果进行判断是否需要重定向。</p>
<ul>
<li>recover可重试条件<br>&emsp;&emsp;请求阶段发生了RouteException或者IOException会进行判断是否重新发起请求<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">try</span> &#123;<br>          response = realChain.proceed(request)<br>          newExchangeFinder = <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">catch</span> (e: RouteException) &#123;<br>          <span class="hljs-comment">/* 路由异常，连接未成功，请求还没发出去 */</span><br>          <span class="hljs-keyword">if</span> (!recover(e.lastConnectException, call, request, requestSendStarted = <span class="hljs-literal">false</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> e.firstConnectException.withSuppressed(recoveredFailures)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            recoveredFailures += e.firstConnectException<br>          &#125;<br>          newExchangeFinder = <span class="hljs-literal">false</span><br>          <span class="hljs-keyword">continue</span><br>        &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>          <span class="hljs-comment">/*请求发出去了，但是和服务器通信失败了(socket流正在读写数据的时候断开连接)。HTTP2才会抛出ConnectionShutdownException，</span><br><span class="hljs-comment">          所以对于HTTP1 requestSendStarted一定是true */</span><br>          <span class="hljs-keyword">if</span> (!recover(e, call, request, requestSendStarted = e !<span class="hljs-keyword">is</span> ConnectionShutdownException)) &#123;<br>            <span class="hljs-keyword">throw</span> e.withSuppressed(recoveredFailures)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            recoveredFailures += e<br>          &#125;<br>          newExchangeFinder = <span class="hljs-literal">false</span><br>          <span class="hljs-keyword">continue</span><br>        &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>&emsp;&emsp;两个异常都是根据recover方法判断是否能够进行重试，如果返回true则表示允许重试</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recover</span><span class="hljs-params">(e: <span class="hljs-type">IOException</span>,call: <span class="hljs-type">RealCall</span>,userRequest: <span class="hljs-type">Request</span>,requestSendStarted: <span class="hljs-type">Boolean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>  <span class="hljs-comment">/* 在配置OkhttpClient是设置了不允许重试（默认允许），则一旦发生请求失败就不再重试 */</span><br>  <span class="hljs-keyword">if</span> (!client.retryOnConnectionFailure) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment">/* 如果是RouteException，不用管这个条件如果是IOException，由于requestSendStarted只在http2的io异常中可能为false，所以主要是第二个条件*/</span><br>  <span class="hljs-keyword">if</span> (requestSendStarted &amp;&amp; requestIsOneShot(e, userRequest)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment">/* 判断是不是属于重试的异常 */</span><br>  <span class="hljs-keyword">if</span> (!isRecoverable(e, requestSendStarted)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-comment">/* 有没有可以用来连接的路由路线 */</span><br>  <span class="hljs-keyword">if</span> (!call.retryAfterFailure()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先使用者在不禁止重试的前提下，如果出现了某些异常，并且存在更多的路由线路，则会尝试换条线路进行请求的重试。其中某些异常是在isRecoverable方法中进行判断</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Kotlin"><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isRecoverable</span><span class="hljs-params">(e: <span class="hljs-type">IOException</span>, requestSendStarted: <span class="hljs-type">Boolean</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>   <span class="hljs-comment">/* 出现协议异常，不能重试 */</span><br>   <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> ProtocolException) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>   &#125;<br>   <span class="hljs-comment">/* 如果不是超时异常，不能重试 */</span><br>   <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> InterruptedIOException) &#123;<br>     <span class="hljs-keyword">return</span> e <span class="hljs-keyword">is</span> SocketTimeoutException &amp;&amp; !requestSendStarted<br>   &#125;<br>  <span class="hljs-comment">/* SSL握手异常中，证书出现问题，不能重试 */</span><br>   <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> SSLHandshakeException) &#123;<br>     <span class="hljs-keyword">if</span> (e.cause <span class="hljs-keyword">is</span> CertificateException) &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>     &#125;<br>   &#125;<br>   <span class="hljs-comment">/* SSL握手未授权异常 不能重试 */</span><br>   <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> SSLPeerUnverifiedException) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br> &#125;<br></code></pre></td></tr></table></figure>

<p>重试流程图<br><img src="https://raw.githubusercontent.com/MilkBeeno/MilkBeeno.github.io.picture/master/2021/network_6.png"><br>&emsp;&emsp;①客户端配置可进行失败重试时(retryOnConnectionFailure==true或requestBody.isOneShot()==false)<br>&emsp;&emsp;②异常不是协议异常时(ProtocolException)<br>&emsp;&emsp;③异常是网络连接中断异常(SocketTimeoutException)<br>&emsp;&emsp;④异常不是SSL证书格式错误、过期时(SSLHandshakeException)<br>&emsp;&emsp;⑤异常不是证书校验失败时(SSLPeerUnverifiedException)<br>&emsp;&emsp;⑥当请求Request含有其他重试路由时、综上五点缺一不可</p>
<ul>
<li>followUpRequest重定向条件<br>&emsp;&emsp;①若Response的code是30x时表示响应头有’Location’字段并重新构建url等于Location中的URL的Request.Build请求、最多重定向次数为20次(MAX_FOLLOW_UPS=20)<br>&emsp;&emsp;②Response的code是407时表示请求经过代理并需验证代理身份,在创建OkhttpClient时需注册代理监听，在回调中重新构建Request为其添加代理验证的请求头(“Proxy-Authorization”)<br>&emsp;&emsp;③code是401时表示服务器要求携带请求头(“Authorization”)<br>&emsp;&emsp;④code是408表示客户端发送超时服务端会返回408、当客户端允许重试时会根据response名为“Retry-After”的header中时间进行重试<br>&emsp;&emsp;⑤code是503表示服务不可用、当客户端允许重试时会立马重试一次(“Retry-After”的header中时间等于0)</li>
</ul>
<h3 id="BridgeInterceptor-桥接拦截器"><a href="#BridgeInterceptor-桥接拦截器" class="headerlink" title="BridgeInterceptor(桥接拦截器)"></a>BridgeInterceptor(桥接拦截器)</h3><p>&emsp;&emsp;对Request参数进行配置、补全请求头、得到响应：①读取Set-Cookie响应头并调用接口告知用户，在下次请求则会读取对应的数据设置进入请求头，默认CookieJar无实现。②响应头Content-Encoding为gzip，使用GzipSource包装解析。</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Content-Type</td>
<td>请求体类型，如：application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Content-Length/Transfer-Encoding</td>
<td>请求体解析方式</td>
</tr>
<tr>
<td>Host</td>
<td>请求的主机站点</td>
</tr>
<tr>
<td>Connection: Keep-Aliv</td>
<td>默认保持长连接</td>
</tr>
<tr>
<td>Accept-Encoding: gzip</td>
<td>接收响应体使用gzip压缩</td>
</tr>
<tr>
<td>Cookie</td>
<td>Cookie身份识别</td>
</tr>
<tr>
<td>User-Agent</td>
<td>用户信息，如：操作系统、浏览器等</td>
</tr>
</tbody></table>
<h3 id="CacheInterceptor-缓存拦截器"><a href="#CacheInterceptor-缓存拦截器" class="headerlink" title="CacheInterceptor(缓存拦截器)"></a>CacheInterceptor(缓存拦截器)</h3><p>&emsp;&emsp;在发出请求前判断是否命中缓存，如果命中则可以不请求，直接使用缓存的响应(只会存在Get请求的缓存)，步骤如下<br>&emsp;&emsp;①从缓存中获得对应请求的响应缓存<br>&emsp;&emsp;②CacheStrategy创建时会判断是否能够使用缓存，在CacheStrategy中存在两个成员：networkRequest与cacheResponse<br>&emsp;&emsp;③交给下一个责任链继续处理<br>&emsp;&emsp;④后续工作，返回304则用缓存的响应；否则使用网络响应并缓存本次响应（只缓存Get请求的响应）</p>
<h3 id="ConnectInterceptor-连接拦截器"><a href="#ConnectInterceptor-连接拦截器" class="headerlink" title="ConnectInterceptor(连接拦截器)"></a>ConnectInterceptor(连接拦截器)</h3><p>&emsp;&emsp;存放Socket的容器、进行网络请求时,若ConnectionPool中有就用当前的、没有就创建新的连接。ConnectionPool中最多能存在最大5个空闲连接、添加新的socket连接后，连接池会不断的执行cleanupTask(首先判断清理任务执行器<TaskRunner>是否已经停止，若停止并可取消则返回、否则将当前taskQueue安排调度，若能成功调度则将此队列从Ready队列中移除并执行清理任务)。</p>
<ul>
<li><p>Route<br>&emsp;&emsp;route为用于连接到服务器的具体路由，其中包含了 IP 地址、端口、代理等参数。由于存在代理或者DNS可能返回多个IP地址的情况，所以同一个接口地址可能会对应多个route。在创建 Connection时将会使用Route而不是直接用IP地址。</p>
</li>
<li><p>RouteSelector<br>&emsp;&emsp;Route选择器，其中存储了所有可用的route，在准备连接时时会通过RouteSelector#next方法获取下一个Route。值得注意的是RouteSelector中包含了一个routeDatabase对象，其中存放着连接失败的Route这是一个黑名单。</p>
</li>
<li><p>RealConnection<br>&emsp;&emsp;实现了Connection接口，其中使用 Socket 建立 HTTP/HTTPS 连接,并且获取 I/O 流，同一个 Connection 可能会承载多个 HTTP 的请求与响应。由于RealConnection事先的是socket连接并获取I/O流，它的实现源码中必然包括了tls、ssl、https协议的相关东西，比如connectTls方法对tls握手协议的实现。</p>
</li>
<li><p>RealConnectionPool<br>&emsp;&emsp;这是用来存储 RealConnection 的池子，内部使用一个双端队列来进行存储。在 OkHttp 中一个连接（RealConnection）用完后不会立马被关闭并释放掉，而且是会存储到连接池（RealConnectionPool）中。除了缓存连接外,缓存池还负责定期清理过期的连接，在 RealConnection 中会维护一个用来描述该连接空闲时间的字段，每添加一个新的连接到连接池中时都会进行一次检测，遍历所有的连接找出当前未被使用且空闲时间最长的那个连接，如果该连接空闲时长超出阈值或者连接池已满将会关闭该连接。另外 RealConnection 中还维护一个 Transmitter 的弱引用列表，用来存储当前正在使用该连接的 Transmitter。当列表为空时表示该连接已经未在使用。</p>
</li>
<li><p>ExchangeCodec<br>&emsp;&emsp;ExchangeCodec 负责对 Request 编码及解码 Response，也就是写入请求及读取响应,我们的请求及响应数据都通过它来读写。所以 Connection 负责建立连接,ExchangeCodec 负责收发数据。ExchangeCodec 接口的实现类有两个：Http1ExchangeCodec及Http2ExchangeCodec分别对应两种协议版本。</p>
</li>
<li><p>Exchange<br>&emsp;&emsp;功能类似 ExchangeCodec，但它是对应的是单个请求，其在 ExchangeCodec 基础上担负了一些连接管理及事件分发的作用具体而言，Exchange 与 Request 一一对应，新建一个请求时就会创建一个 Exchange，该 Exchange 负责将这个请求发送出去并读取到响应数据，而发送与接收数据使用的是 ExchangeCodec。</p>
</li>
<li><p>Transmitter<br>&emsp;&emsp;OkHttp 网络层的桥梁,上面说的这些概念最终都是通过 Transmitter 来融合在一起,并对外提供功能实现。</p>
</li>
</ul>
<h3 id="CallServerInterceptor-请求服务拦截器"><a href="#CallServerInterceptor-请求服务拦截器" class="headerlink" title="CallServerInterceptor(请求服务拦截器)"></a>CallServerInterceptor(请求服务拦截器)</h3><p>&emsp;&emsp;CallServerInterceptor，利用 HttpCodec 发出请求到服务器并且解析生成 Response。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当用户发起一个请求后，会由任务分发起 Dispatcher 将请求包装并交给重试拦截器处理:<br>&emsp;&emsp;(1).重试拦截器在交出(交给下一个拦截器)之前，负责判断用户是否取消了请求；在获得了结果之后，会根据响应码判断是否需要重定向，如果满足条件那么就会重启执行所有拦截器。<br>&emsp;&emsp;(2).桥接拦截器在交出之前，负责将HTTP协议必备的请求头加入其中(如：Host)并添加一些默认的行为(如：GZIP压缩)，在获得了结果后调用保存cookie接口并解析GZIP数据。<br>&emsp;&emsp;(3).缓存拦截器顾名思义，交出之前读取并判断是否使用缓存，获得结果后判断是否缓存。<br>&emsp;&emsp;(4).连接拦截器在交出之前，负责找到或者新建一个连接，并获得对应的socket流，在获得结果后不进行额外的处理。<br>&emsp;&emsp;(5).请求服务器拦截器进行真正的与服务器的通信，向服务器发送数据、解析读取的响应数据。在经过了这一系列的流程后，就完成了一次HTTP请求</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Network" >
    <span class="tag-code">Network</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/04/19/handle/">
        <span class="nav-arrow">← </span>
        
          消息机制
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">导航</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-nav-text">一、计算机网络基础</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-nav-text">计算机网络体系结构</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-nav-text">TCP&#x2F;IP协议族</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Socket%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-nav-text">Socket网络通信</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8E%9F%E7%94%9FJDK%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-BIO"><span class="toc-nav-text">原生JDK网络编程-BIO</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8E%9F%E7%94%9FJDK%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-NIO"><span class="toc-nav-text">原生JDK网络编程-NIO</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#%E4%BA%8C%E3%80%81Okhttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-nav-text">二、Okhttp源码分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">请求流程</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%88%86%E5%8F%91%E5%99%A8Dispatcher"><span class="toc-nav-text">分发器Dispatcher</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#execute%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-nav-text">execute同步请求</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#enqueue%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-nav-text">enqueue异步请求</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-nav-text">拦截器</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#RetryAndFollowUpInterceptor-%E9%87%8D%E8%AF%95%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-nav-text">RetryAndFollowUpInterceptor(重试、重定向拦截器)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#BridgeInterceptor-%E6%A1%A5%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-nav-text">BridgeInterceptor(桥接拦截器)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#CacheInterceptor-%E7%BC%93%E5%AD%98%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-nav-text">CacheInterceptor(缓存拦截器)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#ConnectInterceptor-%E8%BF%9E%E6%8E%A5%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-nav-text">ConnectInterceptor(连接拦截器)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#CallServerInterceptor-%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-nav-text">CallServerInterceptor(请求服务拦截器)</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-nav-text">小结</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://example.com/2021/04/20/network/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>



  <script>
    var gitmentConfig = "MilkBeeno";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "客户端网络通信",
        owner: "MilkBeeno",
        repo: "https://github.com/MilkBeeno",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>



  </body>
</html>