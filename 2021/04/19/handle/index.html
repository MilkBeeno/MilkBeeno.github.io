<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="MilkeBeeno&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Android消息机制 | MilkBeeno
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/androidstudio.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/plugins/gitment.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
    
<script src="/js/gitment.js"></script>

  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
<meta name="generator" content="Hexo 5.4.0"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>MilkBeeno</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">标签</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">归档</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">项目</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">作者</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">首页</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">标签</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">归档</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">项目</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">作者</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Android消息机制</h2>
  <p class="post-date">2021-04-19</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="Handler源码分析"><a href="#Handler源码分析" class="headerlink" title="Handler源码分析"></a>Handler源码分析</h1><p>&emsp;在Android中消息机制主要是handle消息机制，从系统开始运行时就已经决定了handle将会管理系统所有的消息事务，成为系统的维护者。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="http://i1.fuimg.com/736325/86bbb4385df00848.png"><br>&emsp;从上图可以看出handle消息机制主要由Handle、MessageQueue和Looper组成。当handle接收到一个新的消息时，会通过MessageQueue保存并发送出去，而后经过Looper循环再由handle进行处理。<br><img src="http://i1.fuimg.com/736325/5bef946f5f417089.png"><br>&emsp;Handler发送消息有两种方式—post(Runnable)和sendMessage(Message)，结合以上两张图和源码可以得到handle消息调度流程：Handler.sendMessage()-&gt; MessageQueue.enqueueMessage()-&gt; Looper.loop()-&gt; MessageQueue.next()-&gt; Handler.handleMessage()。在handle中我们既可以再主线程发送消息亦可以再子线程发送消息，最终再由handle主线程处理，通过handler消息流程图可知,只有Message不断被发送和接受,创建的Message始终被分配在固定的内存区域中,而内存是没有线程之分,共享内存的方式就可以实现线程间数据通信。</p>
<h2 id="MessageQueue消息队列"><a href="#MessageQueue消息队列" class="headerlink" title="MessageQueue消息队列"></a>MessageQueue消息队列</h2><p>&emsp;MessageQueue是以单链表实现的优先级队列的数据结构保存消息– Message类结构中有一个next对象用来保存下一个Message;MessageQueue中有个mMessages对象用来保存当前队列头部的Message消息;在执行enqueueMessage()插入消息时,将消息插入到对应的位置(不一定是尾部)。</p>
<h3 id="插入消息"><a href="#插入消息" class="headerlink" title="插入消息"></a>插入消息</h3><p>&emsp;Handler机制是一个生产者-消费者模式,MessageQueue是消息的仓库,handler不断的往里发送消息,loop不断轮循取出消息。从源码看出MessageQueue是没有阻塞机制,因此当没有足够的内存可分配时,会导致手机卡死。从handler发送消息流程图可以看出,消息始终会走sendMessageAtTime()函数,并传入参数uptimeMillis最终由MessageQueue进行处理，分析MessageQueue的enqueueMessage(msg, uptimeMillis)函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>      <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>          IllegalStateException e = <span class="hljs-keyword">new</span> IllegalStateException(msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>          Log.w(TAG, e.getMessage(), e);<br>          msg.recycle();<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>      &#125;<br>      msg.markInUse();<br>      <span class="hljs-comment">/** 确定message的执行时刻 */</span><br>      msg.when = when;<br>      <span class="hljs-comment">/** 获取到整个队列消息数据 */</span><br>      Message p = mMessages;<br>      <span class="hljs-keyword">boolean</span> needWake;<br>      <span class="hljs-comment">/**  根据Message的时间进行排序 */</span><br>      <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>          <span class="hljs-comment">/** New head, wake up the event queue if blocked. */</span><br>          msg.next = p;<br>          mMessages = msg;<br>          needWake = mBlocked;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">/** Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span><br><span class="hljs-comment">           up the event queue unless there is a barrier at the head of the queue</span><br><span class="hljs-comment">           and the message is the earliest asynchronous message in the queue. */</span><br>          needWake = mBlocked &amp;&amp; p.target == <span class="hljs-keyword">null</span> &amp;&amp; msg.isAsynchronous();<br>          Message prev;<br>          <span class="hljs-keyword">for</span> (;;) &#123;<br>              prev = p;<br>              p = p.next;<br>              <span class="hljs-comment">/** 从头开始遍历,比较 message 的执行时刻 */</span><br>              <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span> || when &lt; p.when) &#123;<br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>              <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                  needWake = <span class="hljs-keyword">false</span>;<br>              &#125;<br>          &#125;<br>          <span class="hljs-comment">/** invariant p == prev.next 插入数据 */</span><br>          msg.next = p;<br>          prev.next = msg;<br>      &#125;<br>      <span class="hljs-comment">/** We can assume mPtr != 0 because mQuitting is false. */</span><br>      <span class="hljs-keyword">if</span> (needWake) &#123;<br>          nativeWake(mPtr);<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;在MessageQueue的enqueueMessage()方法中有个for的死循环遍历当前消息队列中所有的消息,并和当前要插入的消息进行比较(按时间大小进行比较),然后确定要插入的位置,最后结束循环进行消息的插入(插入排序算法)。</p>
<h3 id="取出消息"><a href="#取出消息" class="headerlink" title="取出消息"></a>取出消息</h3><p>&emsp;Looper作为消息轮询功能，其主要工作在loop()函数完成，在loop()有个for(;;)的死循环将不断的从MessageQueue中取出消息。MessageQueue取出消息直接调用next()函数,且取得的消息永远都是头部的那个Message。从源码可知在native层也会维护一个MessageQueue来存储消息,在next()函数中for死循环不断的调用native的nativePollOnce()函数取出消息。当无消息可取或取得消息还不到处理时候时会进入等待状态(若是在子线程中创建的handler需要退出loop循环,用Looper.quit()方法),等到下一次enqueueMessage调用nativeWake()函数唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@UnsupportedAppUsage</span><br><span class="hljs-function">Message <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pendingIdleHandlerCount = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br>        <span class="hljs-comment">//轮循取出消息</span><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>            Message prevMsg = <span class="hljs-keyword">null</span>;<br>            Message msg = mMessages;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">//消息不到处理时期、进入等待状态</span><br>                    nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now,    <br>                    Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">/** 处理消息代码省略 */</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//没有消息进入无限等待中</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure>

<h3 id="数据安全"><a href="#数据安全" class="headerlink" title="数据安全"></a>数据安全</h3><p>&emsp;多个handler往MessageQueue发送消息时,通过synchronized 内置锁机制(开锁由JVM完成)来保证访问时数据安全问题。</p>
<h2 id="ThreadLocal线程隔离"><a href="#ThreadLocal线程隔离" class="headerlink" title="ThreadLocal线程隔离"></a>ThreadLocal线程隔离</h2><p>&emsp;ThreadLocal本身并不能保存数据,其内部静态类ThreadLocalMap却能保存数据,数据实体Entry一个WeakReference的弱引用,ThreadLocalMap的set(ThreadLocal&lt;?&gt; key, Object value)函数将当前的ThreadLocal和Object将保存到Entry实体中。ThreadLocal保存数据时必然要获取到ThreadLocalMap对象,ThreadLocalMap是保存在当前的线程中,且每一个线程只存在一个ThreadLocalMap的实例,因此保证了线程之间ThreadLocalMap中数据的隔离。ThreadLocal中的set()和get()函数源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//set</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocal.ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><span class="hljs-comment">//get</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocal.ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Looper消息轮询"><a href="#Looper消息轮询" class="headerlink" title="Looper消息轮询"></a>Looper消息轮询</h2><p>&emsp;Looper是消息轮询器,通过它不断向MessageQueue中取出消息,交给Handler分发、处理。源码可知Looper构造私有化,通过prepare()函数进行初始化,在Looper中分别创建了一个Static Final 类型的ThreadLocal<Looper>对象和Final类型的MessageQueue对象,并在构造中MessageQueue完成初始化,从而保证了一个线程只有一个ThreadLocal、Looper和MessageQueue,使其更加可控</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> quitAllowed)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (sThreadLocal.get() != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Only one Looper may be created per thread&quot;</span>);<br>    &#125;<br>    sThreadLocal.set(<span class="hljs-keyword">new</span> Looper(quitAllowed));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;在子线程中创建handler必须调用Looper.prepare()和Looper.loop()方法才能完成handler的消息发送和轮循,并且在队列无消息时要退出loop。</p>
<h2 id="Handler内存泄露"><a href="#Handler内存泄露" class="headerlink" title="Handler内存泄露"></a>Handler内存泄露</h2><p>&emsp;Handler内存泄漏的本质是内部类持有外部类的引用。在Activity或Fragment中创建handler对象,并在handleMessage方法中持有Activity或Fragment中的引用(调用Act或Frag的函数),而Handler的enqueueMessage()函数中,Message的target被赋值this、Message也就持有handler的引用。若handler处理耗时的任务时,更据根可达性算法,Act或Frag的内存将不会得到释放,当内存达到阈值时将会OOM。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,<span class="hljs-keyword">long</span> uptimeMillis)</span> </span>&#123;<br>    <span class="hljs-comment">//持有handler的引用</span><br>    msg.target = <span class="hljs-keyword">this</span>;<br>    msg.workSourceUid = ThreadLocalWorkSource.getUid();<br>    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>        msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;    <br></code></pre></td></tr></table></figure>

<h2 id="同步屏障"><a href="#同步屏障" class="headerlink" title="同步屏障"></a>同步屏障</h2><p>&emsp;Handler消息可以分为两类：同步消息、异步消息,一般发送的都是同步消息。在初始化handler时,无论使用哪个构造方法最终都是调用 public Handler(@Nullable Callback callback, boolean async) 函数,仔细观察参数async在enqueueMessage()插入消息时会进行判断是否为异步,当为异步时会将Message的flags设置为异步消息标识。同步消息和异步消息正常情况下没有什么区别,但在开启同步屏障后,会将异步消息插入到队列头部并确没有给Message的target赋值,postSyncBarrier()函数开启同步屏障</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">postSyncBarrier</span><span class="hljs-params">(<span class="hljs-keyword">long</span> when)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> token = mNextBarrierToken++;<br>        <span class="hljs-keyword">final</span> Message msg = Message.obtain();<br>        msg.markInUse();<br>        msg.when = when;<br>        msg.arg1 = token;<br>        <span class="hljs-comment">//msg.target=this 同步消息插入时将 handler 赋值给 target</span><br>        Message prev = <span class="hljs-keyword">null</span>;<br>        Message p = mMessages;<br>        <span class="hljs-keyword">if</span> (when != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;<br>                prev = p;<br>                p = p.next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将异步消息插入到头部、更新整个消息队列</span><br>        <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>) &#123;<br>            msg.next = p;<br>            prev.next = msg;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            msg.next = p;<br>            mMessages = msg;<br>        &#125;<br>        <span class="hljs-keyword">return</span> token;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;在next()取出消息时，首先会判断是否为异步消息，若为异步消息则立刻将消息返回出去马上处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//是异步消息</span><br><span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.target == <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        prevMsg = msg;<br>        msg = msg.next;<br>    &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; !msg.isAsynchronous());<br>&#125;<br><span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>        <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>        nextPollTimeoutMillis = (<span class="hljs-keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Got a message.</span><br>        mBlocked = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-keyword">null</span>) &#123;<br>            prevMsg.next = msg.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mMessages = msg.next;<br>        &#125;<br>        msg.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message &quot;</span> + msg);<br>        msg.markInUse();<br>        <span class="hljs-comment">//将异步消息返回出去</span><br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure>
<p>&emsp;设置了同步屏障后，handler会优先处理异步消息，异步消息的优先级要高于同步消息，也就验证了MessageQueue是一个优先级队列。Android UI刷新事件在ViewRootImpl.scheduleTraversals中使用了同步屏障</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!mTraversalScheduled) &#123;<br>        mTraversalScheduled = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-comment">/** 开启同步屏障 */</span><br>        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();<br>        mChoreographer.postCallback(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (!mUnbufferedInputDispatch) &#123;<br>            scheduleConsumeBatchedInput();<br>        &#125;<br>        notifyRendererOfFramePending();<br>        pokeDrawLockIfNeeded();<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure>
<p>&emsp;开启同步屏障后调用Choreographer.postCallback()-&gt;Choreographer.postCallbackDelayed()-&gt;Choreographer.postCallbackDelayedInternal()最终发送一个异步消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postCallbackDelayedInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> callbackType,</span></span><br><span class="hljs-function"><span class="hljs-params">                                         Object action, Object token, <span class="hljs-keyword">long</span> delayMillis)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (DEBUG_FRAMES) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;PostCallback type=&quot;</span> + callbackType<br>                + <span class="hljs-string">&quot;, action=&quot;</span> + action + <span class="hljs-string">&quot;, token=&quot;</span> + token<br>                + <span class="hljs-string">&quot;, delayMillis=&quot;</span> + delayMillis);<br>    &#125;<br>    <span class="hljs-keyword">synchronized</span> (mLock) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now = SystemClock.uptimeMillis();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> dueTime = now + delayMillis;<br>        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);<br><br>        <span class="hljs-keyword">if</span> (dueTime &lt;= now) &#123;<br>            scheduleFrameLocked(now);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);<br>            msg.arg1 = callbackType;<br>            msg.setAsynchronous(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-comment">/** 发送异步消息 */</span><br>            mHandler.sendMessageAtTime(msg, dueTime);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;处理完异步消息后，将要移除同步屏障</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unscheduleTraversals</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mTraversalScheduled) &#123;<br>        mTraversalScheduled = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">/** 调用MessageQueue移除同步屏障 */</span><br>        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);<br>        mChoreographer.removeCallbacks(Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure>

<h2 id="HandlerThread的意义"><a href="#HandlerThread的意义" class="headerlink" title="HandlerThread的意义"></a>HandlerThread的意义</h2><p>&emsp;HandlerThread本身是一个public类，继承Thread类其本身是一个线程类，并且内部实现了Looper.prepare()和Looper.loop()方法，所以创建子线程handler时选HandlerThread。使用HandlerThread线程创建handler也保证线程安全问题,在并发多线程中，Looper.prepare()不一定成功，因此创建的handler可能是无效的，所以为了解决异步问题，需要增加锁机制，而HandlerThread内部已经实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   1).IntentService 如何使用Handler分发、处理消息？<br>   2).Looper死循环为什么不会导致ANR？<br>   3).synchronized()锁机制、wait()、notify()方法比较？<br>   4).一个线程有几个handle，如何保证？</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#FrameWork" >
    <span class="tag-code">FrameWork</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/04/12/Jvm/">
        <span class="nav-arrow">← </span>
        
          虚拟机和垃圾回收
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">导航</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-nav-text">Handler源码分析</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-nav-text">工作流程</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#MessageQueue%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-nav-text">MessageQueue消息队列</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%8F%92%E5%85%A5%E6%B6%88%E6%81%AF"><span class="toc-nav-text">插入消息</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%8F%96%E5%87%BA%E6%B6%88%E6%81%AF"><span class="toc-nav-text">取出消息</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8"><span class="toc-nav-text">数据安全</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#ThreadLocal%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB"><span class="toc-nav-text">ThreadLocal线程隔离</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Looper%E6%B6%88%E6%81%AF%E8%BD%AE%E8%AF%A2"><span class="toc-nav-text">Looper消息轮询</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Handler%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="toc-nav-text">Handler内存泄露</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C"><span class="toc-nav-text">同步屏障</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#HandlerThread%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-nav-text">HandlerThread的意义</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-nav-text">总结</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://example.com/2021/04/19/handle/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>



  <script>
    var gitmentConfig = "MilkBeeno";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Android消息机制",
        owner: "MilkBeeno",
        repo: "https://github.com/MilkBeeno",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  </script>




    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>



  </body>
</html>